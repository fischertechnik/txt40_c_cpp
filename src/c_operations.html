<html>
    <head>
        <title>C Operation Reference></title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../css/github-markdown.css">
        <link rel="stylesheet" href="../css/main.css">
        <script>
            function closeMenu() {
                document.getElementById("menu-title").style.display = "block"
                document.getElementById("menu-close").style.display = "none"
                document.getElementById("menu").style.display = "none"

            }

            function showMenu() {
                document.getElementById("menu-title").style.display = "none"
                document.getElementById("menu-close").style.display = "block"
                document.getElementById("menu").style.display = "block"
            }
        </script>
    </head>

    <body>
        <header class="frame menu-bar">
            <div class="menu-control link" style="position: absolute; left: 0px;" onclick="showMenu()">≡</div>
            <h2 class="link" onclick="location.href='../index.html';">TXT 4.0</h2>
        </header>
        <div class="frame menu" id="menu" style="display: none;">
            <h2 class="link" id="menu-title" style="text-align: center;" onclick="location.href='../index.html';">TXT 4.0</h2>
            <div class="menu-control link", id="menu-close" style="display: none;" onclick="closeMenu()">×</div>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="getting_started.html">Getting Started</a></li>
                <li><a href="devices.html">Devices</a></li>
                <li><a href="cpp_interface.html">C++ Interface</a></li>
                <li><a href="c_interface.html" class="selected">C Interface</a></li>
                <li>
                    <ul>
                        <li><a href="c_allocators.html">Allocators</a></li>
                        <li><a href="c_operations.html" class="active">Operations</a></li>
                        <li><a href="c_slaves.html">Slaves</a></li>
                        <li><a href="c_fttypes.html">Types</a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="markdown-body">
            <h1 id="c-operations">C Operations</h1>
<p>The header ftop.h defines functions that operate on devices generated by the
<a href="c_allocators.html">allocator</a> functions. These operations include reading values
from inputs and setting outputs.</p>
<table>
<thead>
<tr>
<th id="content">Content</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#txt-functions"><strong>TXT functions</strong></a></td>
</tr>
<tr>
<td><a href="#can_set_bitrate">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_can_set_bitrate</a></td>
</tr>
<tr>
<td><a href="#get_info">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_finfo</a></td>
</tr>
<tr>
<td><a href="#get_values">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_values</a></td>
</tr>
<tr>
<td><a href="#power_down">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_power_down</a></td>
</tr>
<tr>
<td><a href="#reset">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_reset</a></td>
</tr>
<tr>
<td><a href="#set_terminator">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_set_terminator</a></td>
</tr>
<tr>
<td><a href="#set_uid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_set_uid</a></td>
</tr>
<tr>
<td><a href="#update_config">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_update_config</a></td>
</tr>
<tr>
<td><a href="#wait_event">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_wait_event</a></td>
</tr>
<tr>
<td><a href="#universal-input--counter-functions"><strong>Input & Counter functions</strong></a></td>
</tr>
<tr>
<td><a href="#get_distance">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_distance</a></td>
</tr>
<tr>
<td><a href="#get_resistance">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_resistance</a></td>
</tr>
<tr>
<td><a href="#get_state">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_state</a></td>
</tr>
<tr>
<td><a href="#get_temperature">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_temperature</a></td>
</tr>
<tr>
<td><a href="#get_voltage">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_voltage</a></td>
</tr>
<tr>
<td><a href="#zero">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_zero</a></td>
</tr>
<tr>
<td><a href="#output--servo-functions"><strong>Output & Servo functions</strong></a></td>
</tr>
<tr>
<td><a href="#get_pwm">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_get_pwm</a></td>
</tr>
<tr>
<td><a href="#set_brightness">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_set_brightness</a></td>
</tr>
<tr>
<td><a href="#set_pwm">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_set_pwm</a></td>
</tr>
<tr>
<td><a href="#motor--encoder-functions"><strong>Motor & Encoder functions</strong></a></td>
</tr>
<tr>
<td><a href="#motor_coast">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_coast</a></td>
</tr>
<tr>
<td><a href="#motor_get_distance">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_get_distance</a></td>
</tr>
<tr>
<td><a href="#motor_isrunning">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_isruning</a></td>
</tr>
<tr>
<td><a href="#motor_set_step_counter">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_set_step_counter</a></td>
</tr>
<tr>
<td><a href="#motor_set_speed">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_set_speed</a></td>
</tr>
<tr>
<td><a href="#motor_start_distance">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_start_distance</a></td>
</tr>
<tr>
<td><a href="#motor_start_speed">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_start_speed</a></td>
</tr>
<tr>
<td><a href="#motor_start_sync_distance">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_start_sync_distance</a></td>
</tr>
<tr>
<td><a href="#motor_stop">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_stop</a></td>
</tr>
<tr>
<td><a href="#motor_stop_sync">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftop_motor_stop_sync</a></td>
</tr>
</tbody>
</table>
<h2 id="txt-functions">TXT functions</h2>
<h3 id="span-classtype-idcan_set_bitratevoidspan-ftop_can_set_bitratespan-classtypevoid-spandevice-span-classtypeintspan-speed"><span class="type" id="can_set_bitrate">void</span> ftop_can_set_bitrate(<span class="type">void *</span>device, <span class="type">int</span> speed)</h3>
<p>Sets a new CAN bitrate.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>device</td>
<td>pointer to TXT object.</td>
</tr>
<tr>
<td>in</td>
<td>speed</td>
<td>new CAN bitrate (in Hz)</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idget_infointspan-ftop_get_finfospan-classtypevoid-spandevice-span-classtypeftfaults-spanfinfo"><span class="type" id="get_info">int</span> ftop_get_finfo(<span class="type">void *</span>device, <span class="type">ftfaults *</span>finfo)</h3>
<p>Returns TXT's current fault information.</p>
<!-- See ... for more information on ft_faults (via out parameter).-->
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object</td>
</tr>
<tr>
<td><em>out</em></td>
<td><strong>finfo</strong></td>
<td>pointer to ft_faults struct</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status code (always 0)</p>
<h3 id="span-classtype-idget_valuesintspan-ftop_get_valuesspan-classtypevoid-spandevice-span-classtypeintspan-valuesft_max_inputs--ft_max_counters"><span class="type" id="get_values">int</span> ftop_get_values(<span class="type">void </span>device, <span class="type">int</span> values[<em>12</em>])</h3>
<p>Returns an array with the current values (state for switch and digital, distance
for ultrasonic, raw voltage for resistor/thermistor) for the all inputs and the
current counts for all counters (via out parameter).</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object.</td>
</tr>
<tr>
<td><em>out</em></td>
<td><strong>finfo</strong></td>
<td>pointer to int array with 12 fields</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status code (always 0)</p>
<h3 id="span-classtype-idpower_downvoidspan-ftop_power_downspan-classtypevoid-spandevice"><span class="type" id="power_down">void</span> ftop_power_down(<span class="type">void *</span>device)</h3>
<p>Powers down the M4.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idresetvoidspan-ftop_resetspan-classtypevoid-spandevice"><span class="type" id="reset">void</span> ftop_reset(<span class="type">void *</span>device)</h3>
<p>As of now, this function does nothing.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idset_terminatorvoidspan-ftop_set_terminatorspan-classtypevoid-spandevice-span-classtypeintspan-mode"><span class="type" id="set_terminator">void</span> ftop_set_terminator(<span class="type">void *</span>device, <span class="type">int</span> mode)</h3>
<p>Toggels whether or not to use a termitator for FDCAN.<br />
mode = 0 disabels the terminator, mode = 1 enabels it.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>mode</strong></td>
<td>new mode</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idset_uidvoidspan-ftop_set_uidspan-classtypevoid-spandevice-span-classtypeuint32_tspan-uid"><span class="type" id="set_uid">void</span> ftop_set_uid(<span class="type">void *</span>device, <span class="type">uint32_t</span> uid)</h3>
<p>Sets a new uid for the TXT.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>uid</strong></td>
<td>new uid</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idupdate_configvoidspan-ftop_update_configspan-classtypevoid-spandevice"><span class="type" id="update_config">void</span> ftop_update_config(<span class="type">void *</span>device)</h3>
<p>Updates the TXT's input/output configuration. This function <strong>MUST</strong> be called
after allocating new sensors and actuators for them to become usable. Since
this functions requires communication with the M4, the update is not in effect
immediatly after the function returns, so a sleep might be used to make sure
the peripheral is usuable. For updating the master TXT, 10 <em>ms</em> is sufficient,
updating slave TXT takes up to 70 <em>ms</em>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idwait_eventintspan-ftop_wait_eventspan-classtypevoid-spandevice-span-classtypeuint32_tspan-emask"><span class="type" id="wait_event">int</span> ftop_wait_event(<span class="type">void *</span>device, <span class="type">uint32_t</span> emask)</h3>
<p>Blocks the thread and listens on one or more TXT events. The event types are
specified using a bit mask. The thread is blocked until at least one of the
events was triggered, returning a bit mask containing the detected events from
the original bit mask.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to TXT object</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>emask</strong></td>
<td>bitmask of desired events</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event mask</p>
<h2 id="universal-input--counter-functions">Universal Input &amp; Counter functions</h2>
<h3 id="span-classtype-idget_distanceintspan-ftop_get_distancespan-classtypevoid-spandevice"><span class="type" id="get_distance">int</span> ftop_get_distance(<span class="type">void *</span>device)</h3>
<p>Returns the current distance from a <a href="devices.html#ultrasonic">ultrasonic distance sensor</a> in <em>cm</em>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to ultrasonic object</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance in <em>cm</em></p>
<h3 id="span-classtype-idget_resistanceintspan-ftop_get_resistancespan-classtypevoid-spandevice"><span class="type" id="get_resistance">int</span> ftop_get_resistance(<span class="type">void *</span>device)</h3>
<p>Calulates and returns the resistance for <a href="devices.html#resistor">Resistor</a> and <a href="devices.html#ntc-thermistor">Thermistor</a> devices.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to resistor</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resistance in <em>Ω</em></p>
<h3 id="span-classtype-idget_stateintspan-ftop_get_statespan-classtypevoid-spandevice"><span class="type" id="get_state">int</span> ftop_get_state(<span class="type">void *</span>device)</h3>
<p>Returns the 'state' for universal inputs and counters. For digital devices, the
state is returned, for analog devices, the analog value is returned and for
counters, the count is returned.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to device</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state for digital devices, value for analog devices, count for counters.</p>
<h3 id="span-classtype-idget_temperatureintspan-ftop_get_temperaturespan-classtypevoid-spandevice"><span class="type" id="get_temperature">int</span> ftop_get_temperature(<span class="type">void *</span>device)</h3>
<p>Calculates and returns the temperature in <em>°C</em> for the fischertechnik 1,5 <em>kΩ</em>
<a href="devices.html#ntc-thermistor">NTC</a> using the beta-model.</p>
<p><em>Note:</em> This calculation provides correct results for <strong>THIS</strong> NTC only. For
different thermistors, the user must implement their own function to calculate
the temperature from the resistance.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to thermistor</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temperature in <em>K</em></p>
<h3 id="span-classtype-idget_voltageintspan-ftop_get_voltagespan-classtypevoid-spandevice"><span class="type" id="get_voltage">int</span> ftop_get_voltage(<span class="type">void *</span>device)</h3>
<p>Returns the voltage for <a href="devices.html#voltmeter">voltmeter devices</a>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to voltmeter</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voltage in <em>mV</em></p>
<h3 id="span-classtype-idzerovoidspan-ftop_zerospan-classtypevoid-spandevice"><span class="type" id="zero">void</span> ftop_zero(<span class="type">void *</span>device)</h3>
<p>Resets a <a href="devices.html#counter">counter</a>. This function can be called on a counter
object or on an encoder motor object. In the latter case the counter associated
with the encoder is resetted.</p>
<p><em>Note</em>: This function requires communication with the M4, therefore the reset is
not in affect immediatly after the function is returned but after a brief delay.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to counter or encoder</td>
</tr>
</tbody>
</table>
<h2 id="output--servo-functions">Output &amp; Servo functions</h2>
<h3 id="span-classtype-idget_pwmunsigned-intspan-ftop_get_pwmspan-classtypevoid-spandevice"><span class="type" id="get_pwm">unsigned int</span> ftop_get_pwm(<span class="type">void *</span>device);</h3>
<p>Returns current PWM setting for <a href="devices.html#output-lamp">outputs</a> or <a href="devices.html#servo">servos</a>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to output or servo</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PWM value [<em>0, 512</em>]</p>
<h3 id="span-classtype-idset_brightnessvoidspan-ftop_set_brightnessspan-classtypevoid-spandevice-span-classtypeintspan-value"><span class="type" id="set_brightness">void</span> ftop_set_brightness(<span class="type">void *</span>device, <span class="type">int</span> value)</h3>
<p>Sets the PWM value (brightness) for <a href="devices.html#output-lamp">outputs</a>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to output</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>value</strong></td>
<td>new PWM value [<em>0, 512</em>]</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idset_pwmvoidspan-ftop_set_pwmspan-classtypevoid-spandevice-span-classtypeintspan-value"><span class="type" id="set_pwm">void</span> ftop_set_pwm(<span class="type">void *</span>device, <span class="type">int</span> value)</h3>
<p>Sets the PWM value for <a href="devices.html#output-lamp">outputs</a> or <a href="devices.html#servo">servos</a>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>Pointer to output or servo</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>value</strong></td>
<td>new PWM value [<em>0, 512</em>]</td>
</tr>
</tbody>
</table>
<h2 id="motor--encoder-functions">Motor &amp; Encoder functions</h2>
<h3 id="span-classtype-idmotor_coastvoidspan-ftop_motor_coastspan-classtypevoid-spandevice-span-classtypeintspan-mask"><span class="type" id="motor_coast">void</span> ftop_motor_coast(<span class="type">void *</span>device, <span class="type">int</span> mask)</h3>
<p>Sets <a href="devices.html#motors">motors</a> in "coast mode". The motors are selected using the bit mask.</p>
<p><em>Note</em>: The motors are <strong>NOT</strong> stopped immediatly! The M4 will stop them in its
next update cycle.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to motor or encoder</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>mask</strong></td>
<td>bit mask of selected motors</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idmotor_get_distanceintspan-ftop_motor_get_distancespan-classtypevoid-spandevice"><span class="type" id="motor_get_distance">int</span> ftop_motor_get_distance(<span class="type">void *</span>device)</h3>
<p>Gets the distance covered by the <a href="devices.html#encoder">encoder motor</a>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to encoder</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;covered distance</p>
<h3 id="span-classtype-idmotor_isrunningboolspan-ftop_motor_isrunningspan-classtypevoid-spandevice"><span class="type" id="motor_isrunning">bool</span> ftop_motor_isrunning(<span class="type">void *</span>device)</h3>
<p>Returns whether or not the <a href="devices.html#encoder">encoder motor</a> is currently running.</p>
<p><em>Note</em>: This <strong>does not</strong> mean the motor's cureent speed is non-zero! It checks
whether or not the last motor command has been excecuted or not.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to encoder</td>
</tr>
</tbody>
</table>
<p>Return:  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;motor's state</p>
<h3 id="span-classtype-idmotor_set_step_countervoidspan-ftop_motor_set_step_counterspan-classtypevoid-spandevice-span-classtypevoid-spancounter"><span class="type" id="motor_set_step_counter">void</span> ftop_motor_set_step_counter(<span class="type">void *</span>device, <span class="type">void *</span>counter)</h3>
<p>Sets a new counter for an <a href="devices.html#encoder">encoder motor</a>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to encoder</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>counter</strong></td>
<td>pointer to counter</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idmotor_set_speedvoidspan-ftop_motor_set_speedspan-classtypevoid-spandevice-span-classtypeintspan-speed"><span class="type" id="motor_set_speed">void</span> ftop_motor_set_speed(<span class="type">void *</span>device, <span class="type">int</span> speed)</h3>
<p>Sets a new speed for a <a href="devices.html#motors">motor</a>. The speed is in the range
[-512, 512]. This function does <strong>not</strong> start the motor!</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to motor or encoder</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>speed</strong></td>
<td>new speed [-512, 512]</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idmotor_start_distancevoidspan-ftop_motor_start_distancespan-classtypevoid-spandevice-span-classtypeintspan-distance-span-classtypevoid-spandevice2"><span class="type" id="motor_start_distance">void</span> ftop_motor_start_distance(<span class="type">void *</span>device, <span class="type">int</span> distance, <span class="type">void *</span>device2)</h3>
<p>Immediatly starts the <a href="devices.html#encoder">encoder motor</a> to run for the given
distance. If a second encoder has been passed as argument, both motors run
syncronized. Otherwise, <em>NULL</em> is passed as 3rd argument. Both motors run at
their own speed that was set prior to this function call.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to encoder</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>distance</strong></td>
<td>distance in steps</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>device2</strong></td>
<td>pointer to 2nd encoder or <em>NULL</em></td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idmotor_start_speedvoidspan-ftop_motor_start_speedspan-classtypevoid-spandevice-span-classtypeintspan-speed"><span class="type" id="motor_start_speed">void</span> ftop_motor_start_speed(<span class="type">void *</span>device, <span class="type">int</span> speed)</h3>
<p>Immediatly starts the <a href="devices.html#motors">motor</a> at the given speed.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to motor or encoder</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>speed</strong></td>
<td>new speed [-512, 512]</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idmotor_start_sync_distancevoidspan-ftop_motor_start_sync_distancespan-classtypevoid-spandevice-span-classtypeintspan-distance-span-classtypeintspan-mask"><span class="type" id="motor_start_sync_distance">void</span> ftop_motor_start_sync_distance(<span class="type">void *</span>device, <span class="type">int</span> distance, <span class="type">int</span> mask)</h3>
<p>Immediatly starts all <a href="devices.html#encoder">motors</a> selected by the bit mask. They are syncronized to
run for the given distance, but each motor runs at its own speed that was set using
<a href="#motor_set_speed">ftop_motor_set_speed</a>.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to motor or encoder</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>distance</strong></td>
<td>distance in steps</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>mask</strong></td>
<td>bit mask of selected motors</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idmotor_stopvoidspan-ftop_motor_stopspan-classtypevoid-spandevice"><span class="type" id="motor_stop">void</span> ftop_motor_stop(<span class="type">void *</span>device)</h3>
<p>Immediatly stops motor or encoder.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to encoder</td>
</tr>
</tbody>
</table>
<h3 id="span-classtype-idmotor_stop_syncvoidspan-ftop_motor_stop_syncspan-classtypevoid-spandevice-span-classtypeintspan-mask"><span class="type" id="motor_stop_sync">void</span> ftop_motor_stop_sync(<span class="type">void *</span>device, <span class="type">int</span> mask)</h3>
<p>Immediatly stop all motors and encoders specified by the bit mask.</p>
<table>
<thead>
<tr>
<th id="type">Type</th>
<th id="paremeter">Paremeter</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>in</em></td>
<td><strong>device</strong></td>
<td>pointer to motor or encoder</td>
</tr>
<tr>
<td><em>in</em></td>
<td><strong>mask</strong></td>
<td>bit mask of selected motors</td>
</tr>
</tbody>
</table>
<br>
        </div>
    </body>
</html>